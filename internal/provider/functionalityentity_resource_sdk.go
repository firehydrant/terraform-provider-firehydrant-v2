// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"
	"github.com/firehydrant/terraform-provider-firehydrant/internal/provider/typeconvert"
	tfTypes "github.com/firehydrant/terraform-provider-firehydrant/internal/provider/types"
	"github.com/firehydrant/terraform-provider-firehydrant/internal/sdk/models/operations"
	"github.com/firehydrant/terraform-provider-firehydrant/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *FunctionalityEntityResourceModel) ToSharedCreateFunctionality(ctx context.Context) (*shared.CreateFunctionality, diag.Diagnostics) {
	var diags diag.Diagnostics

	alertOnAdd := new(bool)
	if !r.AlertOnAdd.IsUnknown() && !r.AlertOnAdd.IsNull() {
		*alertOnAdd = r.AlertOnAdd.ValueBool()
	} else {
		alertOnAdd = nil
	}
	autoAddRespondingTeam := new(bool)
	if !r.AutoAddRespondingTeam.IsUnknown() && !r.AutoAddRespondingTeam.IsNull() {
		*autoAddRespondingTeam = r.AutoAddRespondingTeam.ValueBool()
	} else {
		autoAddRespondingTeam = nil
	}
	description := new(string)
	if !r.Description.IsUnknown() && !r.Description.IsNull() {
		*description = r.Description.ValueString()
	} else {
		description = nil
	}
	var externalResourcesInput []shared.CreateFunctionalityExternalResourcesInput
	if r.ExternalResourcesInput != nil {
		externalResourcesInput = make([]shared.CreateFunctionalityExternalResourcesInput, 0, len(r.ExternalResourcesInput))
		for _, externalResourcesInputItem := range r.ExternalResourcesInput {
			connectionType := new(string)
			if !externalResourcesInputItem.ConnectionType.IsUnknown() && !externalResourcesInputItem.ConnectionType.IsNull() {
				*connectionType = externalResourcesInputItem.ConnectionType.ValueString()
			} else {
				connectionType = nil
			}
			var remoteID string
			remoteID = externalResourcesInputItem.RemoteID.ValueString()

			externalResourcesInput = append(externalResourcesInput, shared.CreateFunctionalityExternalResourcesInput{
				ConnectionType: connectionType,
				RemoteID:       remoteID,
			})
		}
	}
	labels := make(map[string]interface{})
	for labelsKey, labelsValue := range r.Labels {
		var labelsInst interface{}
		_ = json.Unmarshal([]byte(labelsValue.ValueString()), &labelsInst)
		labels[labelsKey] = labelsInst
	}
	var linksInput []shared.CreateFunctionalityLinksInput
	if r.LinksInput != nil {
		linksInput = make([]shared.CreateFunctionalityLinksInput, 0, len(r.LinksInput))
		for _, linksInputItem := range r.LinksInput {
			var hrefURL string
			hrefURL = linksInputItem.HrefURL.ValueString()

			iconURL := new(string)
			if !linksInputItem.IconURL.IsUnknown() && !linksInputItem.IconURL.IsNull() {
				*iconURL = linksInputItem.IconURL.ValueString()
			} else {
				iconURL = nil
			}
			var name string
			name = linksInputItem.Name.ValueString()

			linksInput = append(linksInput, shared.CreateFunctionalityLinksInput{
				HrefURL: hrefURL,
				IconURL: iconURL,
				Name:    name,
			})
		}
	}
	var name1 string
	name1 = r.Name.ValueString()

	var ownerInput *shared.CreateFunctionalityOwnerInput
	if r.OwnerInput != nil {
		var id string
		id = r.OwnerInput.ID.ValueString()

		ownerInput = &shared.CreateFunctionalityOwnerInput{
			ID: id,
		}
	}
	var servicesInput []shared.CreateFunctionalityServicesInput
	if r.ServicesInput != nil {
		servicesInput = make([]shared.CreateFunctionalityServicesInput, 0, len(r.ServicesInput))
		for _, servicesInputItem := range r.ServicesInput {
			var id1 string
			id1 = servicesInputItem.ID.ValueString()

			servicesInput = append(servicesInput, shared.CreateFunctionalityServicesInput{
				ID: id1,
			})
		}
	}
	var teamsInput []shared.CreateFunctionalityTeamsInput
	if r.TeamsInput != nil {
		teamsInput = make([]shared.CreateFunctionalityTeamsInput, 0, len(r.TeamsInput))
		for _, teamsInputItem := range r.TeamsInput {
			var id2 string
			id2 = teamsInputItem.ID.ValueString()

			teamsInput = append(teamsInput, shared.CreateFunctionalityTeamsInput{
				ID: id2,
			})
		}
	}
	out := shared.CreateFunctionality{
		AlertOnAdd:             alertOnAdd,
		AutoAddRespondingTeam:  autoAddRespondingTeam,
		Description:            description,
		ExternalResourcesInput: externalResourcesInput,
		Labels:                 labels,
		LinksInput:             linksInput,
		Name:                   name1,
		OwnerInput:             ownerInput,
		ServicesInput:          servicesInput,
		TeamsInput:             teamsInput,
	}

	return &out, diags
}

func (r *FunctionalityEntityResourceModel) ToSharedUpdateFunctionality(ctx context.Context) (*shared.UpdateFunctionality, diag.Diagnostics) {
	var diags diag.Diagnostics

	alertOnAdd := new(bool)
	if !r.AlertOnAdd.IsUnknown() && !r.AlertOnAdd.IsNull() {
		*alertOnAdd = r.AlertOnAdd.ValueBool()
	} else {
		alertOnAdd = nil
	}
	autoAddRespondingTeam := new(bool)
	if !r.AutoAddRespondingTeam.IsUnknown() && !r.AutoAddRespondingTeam.IsNull() {
		*autoAddRespondingTeam = r.AutoAddRespondingTeam.ValueBool()
	} else {
		autoAddRespondingTeam = nil
	}
	description := new(string)
	if !r.Description.IsUnknown() && !r.Description.IsNull() {
		*description = r.Description.ValueString()
	} else {
		description = nil
	}
	var externalResourcesInput []shared.UpdateFunctionalityExternalResourcesInput
	if r.ExternalResourcesInput != nil {
		externalResourcesInput = make([]shared.UpdateFunctionalityExternalResourcesInput, 0, len(r.ExternalResourcesInput))
		for _, externalResourcesInputItem := range r.ExternalResourcesInput {
			connectionType := new(string)
			if !externalResourcesInputItem.ConnectionType.IsUnknown() && !externalResourcesInputItem.ConnectionType.IsNull() {
				*connectionType = externalResourcesInputItem.ConnectionType.ValueString()
			} else {
				connectionType = nil
			}
			var remoteID string
			remoteID = externalResourcesInputItem.RemoteID.ValueString()

			externalResourcesInput = append(externalResourcesInput, shared.UpdateFunctionalityExternalResourcesInput{
				ConnectionType: connectionType,
				RemoteID:       remoteID,
			})
		}
	}
	labels := make(map[string]interface{})
	for labelsKey, labelsValue := range r.Labels {
		var labelsInst interface{}
		_ = json.Unmarshal([]byte(labelsValue.ValueString()), &labelsInst)
		labels[labelsKey] = labelsInst
	}
	var linksInput []shared.UpdateFunctionalityLinksInput
	if r.LinksInput != nil {
		linksInput = make([]shared.UpdateFunctionalityLinksInput, 0, len(r.LinksInput))
		for _, linksInputItem := range r.LinksInput {
			var hrefURL string
			hrefURL = linksInputItem.HrefURL.ValueString()

			iconURL := new(string)
			if !linksInputItem.IconURL.IsUnknown() && !linksInputItem.IconURL.IsNull() {
				*iconURL = linksInputItem.IconURL.ValueString()
			} else {
				iconURL = nil
			}
			id := new(string)
			if !linksInputItem.Name.IsUnknown() && !linksInputItem.Name.IsNull() {
				*id = linksInputItem.Name.ValueString()
			} else {
				id = nil
			}
			var name string
			name = linksInputItem.Name.ValueString()

			linksInput = append(linksInput, shared.UpdateFunctionalityLinksInput{
				HrefURL: hrefURL,
				IconURL: iconURL,
				ID:      id,
				Name:    name,
			})
		}
	}
	name1 := new(string)
	if !r.Name.IsUnknown() && !r.Name.IsNull() {
		*name1 = r.Name.ValueString()
	} else {
		name1 = nil
	}
	var ownerInput *shared.UpdateFunctionalityOwnerInput
	if r.OwnerInput != nil {
		var id1 string
		id1 = r.OwnerInput.ID.ValueString()

		ownerInput = &shared.UpdateFunctionalityOwnerInput{
			ID: id1,
		}
	}
	var servicesInput []shared.UpdateFunctionalityServicesInput
	if r.ServicesInput != nil {
		servicesInput = make([]shared.UpdateFunctionalityServicesInput, 0, len(r.ServicesInput))
		for _, servicesInputItem := range r.ServicesInput {
			var id2 string
			id2 = servicesInputItem.ID.ValueString()

			servicesInput = append(servicesInput, shared.UpdateFunctionalityServicesInput{
				ID: id2,
			})
		}
	}
	var teamsInput []shared.UpdateFunctionalityTeamsInput
	if r.TeamsInput != nil {
		teamsInput = make([]shared.UpdateFunctionalityTeamsInput, 0, len(r.TeamsInput))
		for _, teamsInputItem := range r.TeamsInput {
			var id3 string
			id3 = teamsInputItem.ID.ValueString()

			teamsInput = append(teamsInput, shared.UpdateFunctionalityTeamsInput{
				ID: id3,
			})
		}
	}
	out := shared.UpdateFunctionality{
		AlertOnAdd:             alertOnAdd,
		AutoAddRespondingTeam:  autoAddRespondingTeam,
		Description:            description,
		ExternalResourcesInput: externalResourcesInput,
		Labels:                 labels,
		LinksInput:             linksInput,
		Name:                   name1,
		OwnerInput:             ownerInput,
		ServicesInput:          servicesInput,
		TeamsInput:             teamsInput,
	}

	return &out, diags
}

func (r *FunctionalityEntityResourceModel) ToOperationsUpdateFunctionalityRequest(ctx context.Context) (*operations.UpdateFunctionalityRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var functionalityID string
	functionalityID = r.ID.ValueString()

	updateFunctionality, updateFunctionalityDiags := r.ToSharedUpdateFunctionality(ctx)
	diags.Append(updateFunctionalityDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateFunctionalityRequest{
		FunctionalityID:     functionalityID,
		UpdateFunctionality: *updateFunctionality,
	}

	return &out, diags
}

func (r *FunctionalityEntityResourceModel) ToOperationsGetFunctionalityRequest(ctx context.Context) (*operations.GetFunctionalityRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var functionalityID string
	functionalityID = r.ID.ValueString()

	out := operations.GetFunctionalityRequest{
		FunctionalityID: functionalityID,
	}

	return &out, diags
}

func (r *FunctionalityEntityResourceModel) ToOperationsDeleteFunctionalityRequest(ctx context.Context) (*operations.DeleteFunctionalityRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var functionalityID string
	functionalityID = r.ID.ValueString()

	out := operations.DeleteFunctionalityRequest{
		FunctionalityID: functionalityID,
	}

	return &out, diags
}

func (r *FunctionalityEntityResourceModel) RefreshFromSharedFunctionalityEntity(ctx context.Context, resp *shared.FunctionalityEntity) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		if resp.ActiveIncidents != nil {
			r.ActiveIncidents = make([]types.String, 0, len(resp.ActiveIncidents))
			for _, v := range resp.ActiveIncidents {
				r.ActiveIncidents = append(r.ActiveIncidents, types.StringValue(v))
			}
		}
		r.AlertOnAdd = types.BoolPointerValue(resp.AlertOnAdd)
		r.AutoAddRespondingTeam = types.BoolPointerValue(resp.AutoAddRespondingTeam)
		r.CreatedAt = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreatedAt))
		r.Description = types.StringPointerValue(resp.Description)
		if resp.ExternalResources != nil {
			r.ExternalResources = []tfTypes.ExternalResourceEntity{}
			if len(r.ExternalResources) > len(resp.ExternalResources) {
				r.ExternalResources = r.ExternalResources[:len(resp.ExternalResources)]
			}
			for externalResourcesCount, externalResourcesItem := range resp.ExternalResources {
				var externalResources tfTypes.ExternalResourceEntity
				externalResources.ConnectionFullFaviconURL = types.StringPointerValue(externalResourcesItem.ConnectionFullFaviconURL)
				externalResources.ConnectionID = types.StringPointerValue(externalResourcesItem.ConnectionID)
				externalResources.ConnectionName = types.StringPointerValue(externalResourcesItem.ConnectionName)
				externalResources.ConnectionType = types.StringPointerValue(externalResourcesItem.ConnectionType)
				externalResources.CreatedAt = types.StringPointerValue(typeconvert.TimePointerToStringPointer(externalResourcesItem.CreatedAt))
				externalResources.Name = types.StringPointerValue(externalResourcesItem.Name)
				externalResources.RemoteID = types.StringPointerValue(externalResourcesItem.RemoteID)
				externalResources.RemoteURL = types.StringPointerValue(externalResourcesItem.RemoteURL)
				externalResources.UpdatedAt = types.StringPointerValue(typeconvert.TimePointerToStringPointer(externalResourcesItem.UpdatedAt))
				if externalResourcesCount+1 > len(r.ExternalResources) {
					r.ExternalResources = append(r.ExternalResources, externalResources)
				} else {
					r.ExternalResources[externalResourcesCount].ConnectionFullFaviconURL = externalResources.ConnectionFullFaviconURL
					r.ExternalResources[externalResourcesCount].ConnectionID = externalResources.ConnectionID
					r.ExternalResources[externalResourcesCount].ConnectionName = externalResources.ConnectionName
					r.ExternalResources[externalResourcesCount].ConnectionType = externalResources.ConnectionType
					r.ExternalResources[externalResourcesCount].CreatedAt = externalResources.CreatedAt
					r.ExternalResources[externalResourcesCount].Name = externalResources.Name
					r.ExternalResources[externalResourcesCount].RemoteID = externalResources.RemoteID
					r.ExternalResources[externalResourcesCount].RemoteURL = externalResources.RemoteURL
					r.ExternalResources[externalResourcesCount].UpdatedAt = externalResources.UpdatedAt
				}
			}
		}
		r.ID = types.StringPointerValue(resp.ID)
		if resp.Labels != nil {
			r.Labels = make(map[string]types.String, len(resp.Labels))
			for key, value := range resp.Labels {
				result, _ := json.Marshal(value)
				r.Labels[key] = types.StringValue(string(result))
			}
		}
		if resp.Links != nil {
			r.Links = []tfTypes.LinksEntity{}
			if len(r.Links) > len(resp.Links) {
				r.Links = r.Links[:len(resp.Links)]
			}
			for linksCount, linksItem := range resp.Links {
				var links tfTypes.LinksEntity
				links.HrefURL = types.StringPointerValue(linksItem.HrefURL)
				links.IconURL = types.StringPointerValue(linksItem.IconURL)
				links.ID = types.StringPointerValue(linksItem.ID)
				links.Name = types.StringPointerValue(linksItem.Name)
				if linksCount+1 > len(r.Links) {
					r.Links = append(r.Links, links)
				} else {
					r.Links[linksCount].HrefURL = links.HrefURL
					r.Links[linksCount].IconURL = links.IconURL
					r.Links[linksCount].ID = links.ID
					r.Links[linksCount].Name = links.Name
				}
			}
		}
		r.Name = types.StringPointerValue(resp.Name)
		if resp.Owner == nil {
			r.Owner = nil
		} else {
			r.Owner = &tfTypes.NullableTeamEntityLite{}
			r.Owner.CreatedAt = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.Owner.CreatedAt))
			if resp.Owner.CreatedBy == nil {
				r.Owner.CreatedBy = nil
			} else {
				r.Owner.CreatedBy = &tfTypes.NullableAuthorEntity{}
				r.Owner.CreatedBy.Email = types.StringPointerValue(resp.Owner.CreatedBy.Email)
				r.Owner.CreatedBy.ID = types.StringPointerValue(resp.Owner.CreatedBy.ID)
				r.Owner.CreatedBy.Name = types.StringPointerValue(resp.Owner.CreatedBy.Name)
				r.Owner.CreatedBy.Source = types.StringPointerValue(resp.Owner.CreatedBy.Source)
			}
			r.Owner.Description = types.StringPointerValue(resp.Owner.Description)
			r.Owner.ID = types.StringPointerValue(resp.Owner.ID)
			r.Owner.InSupportHours = types.BoolPointerValue(resp.Owner.InSupportHours)
			r.Owner.Name = types.StringPointerValue(resp.Owner.Name)
			r.Owner.SignalsIcalURL = types.StringPointerValue(resp.Owner.SignalsIcalURL)
			r.Owner.Slug = types.StringPointerValue(resp.Owner.Slug)
			r.Owner.UpdatedAt = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.Owner.UpdatedAt))
		}
		if resp.Services != nil {
			r.Services = []tfTypes.ServiceEntityLite{}
			if len(r.Services) > len(resp.Services) {
				r.Services = r.Services[:len(resp.Services)]
			}
			for servicesCount, servicesItem := range resp.Services {
				var services tfTypes.ServiceEntityLite
				services.AlertOnAdd = types.BoolPointerValue(servicesItem.AlertOnAdd)
				if servicesItem.AllowedParams != nil {
					services.AllowedParams = make([]types.String, 0, len(servicesItem.AllowedParams))
					for _, v := range servicesItem.AllowedParams {
						services.AllowedParams = append(services.AllowedParams, types.StringValue(v))
					}
				}
				services.AutoAddRespondingTeam = types.BoolPointerValue(servicesItem.AutoAddRespondingTeam)
				services.CreatedAt = types.StringPointerValue(typeconvert.TimePointerToStringPointer(servicesItem.CreatedAt))
				services.Description = types.StringPointerValue(servicesItem.Description)
				services.ID = types.StringPointerValue(servicesItem.ID)
				if servicesItem.Labels == nil {
					services.Labels = nil
				} else {
					services.Labels = &tfTypes.ServiceEntityLiteLabels{}
				}
				services.Name = types.StringPointerValue(servicesItem.Name)
				services.ServiceTier = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(servicesItem.ServiceTier))
				services.Slug = types.StringPointerValue(servicesItem.Slug)
				services.UpdatedAt = types.StringPointerValue(typeconvert.TimePointerToStringPointer(servicesItem.UpdatedAt))
				if servicesCount+1 > len(r.Services) {
					r.Services = append(r.Services, services)
				} else {
					r.Services[servicesCount].AlertOnAdd = services.AlertOnAdd
					r.Services[servicesCount].AllowedParams = services.AllowedParams
					r.Services[servicesCount].AutoAddRespondingTeam = services.AutoAddRespondingTeam
					r.Services[servicesCount].CreatedAt = services.CreatedAt
					r.Services[servicesCount].Description = services.Description
					r.Services[servicesCount].ID = services.ID
					r.Services[servicesCount].Labels = services.Labels
					r.Services[servicesCount].Name = services.Name
					r.Services[servicesCount].ServiceTier = services.ServiceTier
					r.Services[servicesCount].Slug = services.Slug
					r.Services[servicesCount].UpdatedAt = services.UpdatedAt
				}
			}
		}
		r.Slug = types.StringPointerValue(resp.Slug)
		if resp.Teams != nil {
			r.Teams = []tfTypes.TeamEntityLite{}
			if len(r.Teams) > len(resp.Teams) {
				r.Teams = r.Teams[:len(resp.Teams)]
			}
			for teamsCount, teamsItem := range resp.Teams {
				var teams tfTypes.TeamEntityLite
				teams.CreatedAt = types.StringPointerValue(typeconvert.TimePointerToStringPointer(teamsItem.CreatedAt))
				if teamsItem.CreatedBy == nil {
					teams.CreatedBy = nil
				} else {
					teams.CreatedBy = &tfTypes.NullableAuthorEntity{}
					teams.CreatedBy.Email = types.StringPointerValue(teamsItem.CreatedBy.Email)
					teams.CreatedBy.ID = types.StringPointerValue(teamsItem.CreatedBy.ID)
					teams.CreatedBy.Name = types.StringPointerValue(teamsItem.CreatedBy.Name)
					teams.CreatedBy.Source = types.StringPointerValue(teamsItem.CreatedBy.Source)
				}
				teams.Description = types.StringPointerValue(teamsItem.Description)
				teams.ID = types.StringPointerValue(teamsItem.ID)
				teams.InSupportHours = types.BoolPointerValue(teamsItem.InSupportHours)
				teams.Name = types.StringPointerValue(teamsItem.Name)
				teams.SignalsIcalURL = types.StringPointerValue(teamsItem.SignalsIcalURL)
				teams.Slug = types.StringPointerValue(teamsItem.Slug)
				teams.UpdatedAt = types.StringPointerValue(typeconvert.TimePointerToStringPointer(teamsItem.UpdatedAt))
				if teamsCount+1 > len(r.Teams) {
					r.Teams = append(r.Teams, teams)
				} else {
					r.Teams[teamsCount].CreatedAt = teams.CreatedAt
					r.Teams[teamsCount].CreatedBy = teams.CreatedBy
					r.Teams[teamsCount].Description = teams.Description
					r.Teams[teamsCount].ID = teams.ID
					r.Teams[teamsCount].InSupportHours = teams.InSupportHours
					r.Teams[teamsCount].Name = teams.Name
					r.Teams[teamsCount].SignalsIcalURL = teams.SignalsIcalURL
					r.Teams[teamsCount].Slug = teams.Slug
					r.Teams[teamsCount].UpdatedAt = teams.UpdatedAt
				}
			}
		}
		r.UpdatedAt = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.UpdatedAt))
		if resp.UpdatedBy == nil {
			r.UpdatedBy = nil
		} else {
			r.UpdatedBy = &tfTypes.NullableAuthorEntity{}
			r.UpdatedBy.Email = types.StringPointerValue(resp.UpdatedBy.Email)
			r.UpdatedBy.ID = types.StringPointerValue(resp.UpdatedBy.ID)
			r.UpdatedBy.Name = types.StringPointerValue(resp.UpdatedBy.Name)
			r.UpdatedBy.Source = types.StringPointerValue(resp.UpdatedBy.Source)
		}
	}

	return diags
}

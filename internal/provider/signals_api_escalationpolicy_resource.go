// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	tfTypes "github.com/firehydrant/terraform-provider-firehydrant/internal/provider/types"
	"github.com/firehydrant/terraform-provider-firehydrant/internal/sdk"
	"github.com/firehydrant/terraform-provider-firehydrant/internal/validators"
	speakeasy_listvalidators "github.com/firehydrant/terraform-provider-firehydrant/internal/validators/listvalidators"
	speakeasy_objectvalidators "github.com/firehydrant/terraform-provider-firehydrant/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/firehydrant/terraform-provider-firehydrant/internal/validators/stringvalidators"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int32default"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &SignalsAPIEscalationPolicyResource{}
var _ resource.ResourceWithImportState = &SignalsAPIEscalationPolicyResource{}

func NewSignalsAPIEscalationPolicyResource() resource.Resource {
	return &SignalsAPIEscalationPolicyResource{}
}

// SignalsAPIEscalationPolicyResource defines the resource implementation.
type SignalsAPIEscalationPolicyResource struct {
	// Provider configured SDK client.
	client *sdk.Firehydrant
}

// SignalsAPIEscalationPolicyResourceModel describes the resource data model.
type SignalsAPIEscalationPolicyResourceModel struct {
	CreatedAt                    types.String                                           `tfsdk:"created_at"`
	CreatedBy                    *tfTypes.NullableAuthor                                `tfsdk:"created_by"`
	Default                      types.Bool                                             `tfsdk:"default"`
	Description                  types.String                                           `tfsdk:"description"`
	HandoffStep                  *tfTypes.NullableSignalsAPIEscalationPolicyHandoffStep `tfsdk:"handoff_step"`
	HandoffStepInput             *tfTypes.CreateTeamEscalationPolicyHandoffStepInput    `tfsdk:"handoff_step_input"`
	ID                           types.String                                           `tfsdk:"id"`
	Name                         types.String                                           `tfsdk:"name"`
	NotificationPriorityPolicies []tfTypes.SignalsAPINotificationPriorityPolicy         `tfsdk:"notification_priority_policies"`
	PrioritizedSettings          *tfTypes.CreateTeamEscalationPolicyPrioritizedSettings `tfsdk:"prioritized_settings"`
	Repetitions                  types.Int32                                            `tfsdk:"repetitions"`
	StepStrategy                 types.String                                           `tfsdk:"step_strategy"`
	Steps                        []tfTypes.SignalsAPIEscalationPolicyStep1              `tfsdk:"steps"`
	TeamID                       types.String                                           `tfsdk:"team_id"`
	UpdatedAt                    types.String                                           `tfsdk:"updated_at"`
}

func (r *SignalsAPIEscalationPolicyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_signals_api_escalation_policy"
}

func (r *SignalsAPIEscalationPolicyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "SignalsAPIEscalationPolicy Resource",
		Attributes: map[string]schema.Attribute{
			"created_at": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"created_by": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"email": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"source": schema.StringAttribute{
						Computed: true,
					},
				},
			},
			"default": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Default:     booldefault.StaticBool(false),
				Description: `Whether this escalation policy should be the default for the team. Default: false`,
			},
			"description": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `A detailed description of the escalation policy.`,
			},
			"handoff_step": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Computed: true,
					},
					"target": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Computed: true,
							},
							"is_pageable": schema.BoolAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"team_id": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed: true,
							},
						},
					},
				},
			},
			"handoff_step_input": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"target_id": schema.StringAttribute{
						Required:    true,
						Description: `The ID of the target to which the policy will hand off.`,
					},
					"target_type": schema.StringAttribute{
						Required:    true,
						Description: `The type of target to which the policy will hand off.`,
					},
				},
				Description: `A step that defines where an alert should be sent when the policy is exhausted and the alert is still unacknowledged.`,
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:    true,
				Description: `The escalation policy's name.`,
			},
			"notification_priority_policies": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"handoff_step": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Computed: true,
								},
								"target": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"id": schema.StringAttribute{
											Computed: true,
										},
										"is_pageable": schema.BoolAttribute{
											Computed: true,
										},
										"name": schema.StringAttribute{
											Computed: true,
										},
										"team_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed: true,
										},
									},
								},
							},
						},
						"notification_priority": schema.StringAttribute{
							Computed:    true,
							Description: `The notification priority this policy handles (HIGH, MEDIUM, or LOW)`,
						},
						"repetitions": schema.Int32Attribute{
							Computed:    true,
							Description: `Number of repetitions for this priority`,
						},
						"steps": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"distribution_type": schema.StringAttribute{
										Computed:    true,
										Description: `The distribution type for the step`,
									},
									"id": schema.StringAttribute{
										Computed: true,
									},
									"next_target_for_round_robin": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"id": schema.StringAttribute{
												Computed: true,
											},
											"is_pageable": schema.BoolAttribute{
												Computed: true,
											},
											"name": schema.StringAttribute{
												Computed: true,
											},
											"team_id": schema.StringAttribute{
												Computed: true,
											},
											"type": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"parent_position": schema.Int32Attribute{
										Computed: true,
									},
									"position": schema.Int32Attribute{
										Computed: true,
									},
									"priorities": schema.ListAttribute{
										Computed:    true,
										ElementType: types.StringType,
										Description: `The notification priorities that this step is assigned to. Valid values are HIGH, MEDIUM, and LOW.`,
									},
									"targets": schema.ListNestedAttribute{
										Computed: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Computed: true,
												},
												"is_pageable": schema.BoolAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"team_id": schema.StringAttribute{
													Computed: true,
												},
												"type": schema.StringAttribute{
													Computed: true,
												},
											},
										},
									},
									"timeout": schema.StringAttribute{
										Computed: true,
									},
								},
							},
							Description: `Steps for this priority`,
						},
					},
				},
				Description: `Priority-specific policies for dynamic escalation policies`,
			},
			"prioritized_settings": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"high": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"handoff_step": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"target_id": schema.StringAttribute{
										Required: true,
									},
									"target_type": schema.StringAttribute{
										Required: true,
									},
								},
								Description: `Handoff step for HIGH priority alerts`,
							},
							"repetitions": schema.Int32Attribute{
								Optional:    true,
								Description: `Number of repetitions for HIGH priority alerts`,
							},
						},
						Description: `Settings for HIGH priority alerts`,
					},
					"low": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"handoff_step": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"target_id": schema.StringAttribute{
										Required: true,
									},
									"target_type": schema.StringAttribute{
										Required: true,
									},
								},
								Description: `Handoff step for LOW priority alerts`,
							},
							"repetitions": schema.Int32Attribute{
								Optional:    true,
								Description: `Number of repetitions for LOW priority alerts`,
							},
						},
						Description: `Settings for LOW priority alerts`,
					},
					"medium": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"handoff_step": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"target_id": schema.StringAttribute{
										Required: true,
									},
									"target_type": schema.StringAttribute{
										Required: true,
									},
								},
								Description: `Handoff step for MEDIUM priority alerts`,
							},
							"repetitions": schema.Int32Attribute{
								Optional:    true,
								Description: `Number of repetitions for MEDIUM priority alerts`,
							},
						},
						Description: `Settings for MEDIUM priority alerts`,
					},
				},
				Description: `Priority-specific settings for dynamic escalation policies`,
			},
			"repetitions": schema.Int32Attribute{
				Computed:    true,
				Optional:    true,
				Default:     int32default.StaticInt32(0),
				Description: `The number of times that the escalation policy should repeat before an alert is dropped. Default: 0`,
			},
			"step_strategy": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The strategy for handling steps in the escalation policy. Can be "static" or "dynamic_by_priority".`,
			},
			"steps": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					Attributes: map[string]schema.Attribute{
						"distribution_type": schema.StringAttribute{
							Computed:    true,
							Optional:    true,
							Description: `The round robin configuration for the step. One of 'unspecified', 'round_robin_by_alert', or 'round_robin_by_escalation_policy'.`,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"next_target_for_round_robin": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Computed: true,
								},
								"is_pageable": schema.BoolAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"team_id": schema.StringAttribute{
									Computed: true,
								},
								"type": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"parent_position": schema.Int32Attribute{
							Computed: true,
						},
						"position": schema.Int32Attribute{
							Computed: true,
						},
						"priorities": schema.ListAttribute{
							Computed:    true,
							Optional:    true,
							ElementType: types.StringType,
							Description: `A list of priorities (HIGH, MEDIUM, LOW) to which the step applies when using a dynamic escalation policy.`,
						},
						"targets": schema.ListNestedAttribute{
							Computed: true,
							Optional: true,
							NestedObject: schema.NestedAttributeObject{
								Validators: []validator.Object{
									speakeasy_objectvalidators.NotNull(),
								},
								Attributes: map[string]schema.Attribute{
									"id": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Description: `The ID of the target that the step will notify. Not Null`,
										Validators: []validator.String{
											speakeasy_stringvalidators.NotNull(),
										},
									},
									"is_pageable": schema.BoolAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"team_id": schema.StringAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Description: `The type of target that the step will notify. Not Null`,
										Validators: []validator.String{
											speakeasy_stringvalidators.NotNull(),
										},
									},
								},
							},
							Description: `A list of targets that the step will notify. You can specify up to 15 targets per step. Not Null`,
							Validators: []validator.List{
								speakeasy_listvalidators.NotNull(),
							},
						},
						"timeout": schema.StringAttribute{
							Computed:    true,
							Optional:    true,
							Description: `An ISO8601 duration string specifying how long to wait before moving on to the next step. For the last step, this value specifies how long to wait before the escalation policy should repeat, if it repeats. Not Null`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
							},
						},
					},
				},
				Description: `A list of steps that define how an alert should escalate through the policy.`,
			},
			"team_id": schema.StringAttribute{
				Required: true,
			},
			"updated_at": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
		},
	}
}

func (r *SignalsAPIEscalationPolicyResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.Firehydrant)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.Firehydrant, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *SignalsAPIEscalationPolicyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *SignalsAPIEscalationPolicyResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsCreateTeamEscalationPolicyRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Signals.CreateTeamEscalationPolicy(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 201 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.SignalsAPIEscalationPolicy != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedSignalsAPIEscalationPolicy(ctx, res.SignalsAPIEscalationPolicy)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetTeamEscalationPolicyRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Signals.GetTeamEscalationPolicy(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.SignalsAPIEscalationPolicy != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedSignalsAPIEscalationPolicy(ctx, res1.SignalsAPIEscalationPolicy)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SignalsAPIEscalationPolicyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *SignalsAPIEscalationPolicyResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsGetTeamEscalationPolicyRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Signals.GetTeamEscalationPolicy(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.SignalsAPIEscalationPolicy != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedSignalsAPIEscalationPolicy(ctx, res.SignalsAPIEscalationPolicy)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SignalsAPIEscalationPolicyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *SignalsAPIEscalationPolicyResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateTeamEscalationPolicyRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Signals.UpdateTeamEscalationPolicy(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.SignalsAPIEscalationPolicy != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedSignalsAPIEscalationPolicy(ctx, res.SignalsAPIEscalationPolicy)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetTeamEscalationPolicyRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Signals.GetTeamEscalationPolicy(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.SignalsAPIEscalationPolicy != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedSignalsAPIEscalationPolicy(ctx, res1.SignalsAPIEscalationPolicy)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SignalsAPIEscalationPolicyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *SignalsAPIEscalationPolicyResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; entity does not have a configured DELETE operation
}

func (r *SignalsAPIEscalationPolicyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	dec := json.NewDecoder(bytes.NewReader([]byte(req.ID)))
	dec.DisallowUnknownFields()
	var data struct {
		ID     string `json:"id"`
		TeamID string `json:"team_id"`
	}

	if err := dec.Decode(&data); err != nil {
		resp.Diagnostics.AddError("Invalid ID", `The import ID is not valid. It is expected to be a JSON object string with the format: '{"id": "", "team_id": ""}': `+err.Error())
		return
	}

	if len(data.ID) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field id is required but was not found in the json encoded ID. It's expected to be a value alike '""`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), data.ID)...)
	if len(data.TeamID) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field team_id is required but was not found in the json encoded ID. It's expected to be a value alike '""`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("team_id"), data.TeamID)...)
}

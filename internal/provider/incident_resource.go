// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	speakeasy_listplanmodifier "github.com/firehydrant/terraform-provider-firehydrant/internal/planmodifiers/listplanmodifier"
	speakeasy_objectplanmodifier "github.com/firehydrant/terraform-provider-firehydrant/internal/planmodifiers/objectplanmodifier"
	speakeasy_stringplanmodifier "github.com/firehydrant/terraform-provider-firehydrant/internal/planmodifiers/stringplanmodifier"
	tfTypes "github.com/firehydrant/terraform-provider-firehydrant/internal/provider/types"
	"github.com/firehydrant/terraform-provider-firehydrant/internal/sdk"
	"github.com/firehydrant/terraform-provider-firehydrant/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &IncidentResource{}
var _ resource.ResourceWithImportState = &IncidentResource{}

func NewIncidentResource() resource.Resource {
	return &IncidentResource{}
}

// IncidentResource defines the resource implementation.
type IncidentResource struct {
	// Provider configured SDK client.
	client *sdk.Firehydrant
}

// IncidentResourceModel describes the resource data model.
type IncidentResourceModel struct {
	Active                  types.Bool                               `tfsdk:"active"`
	AiIncidentSummary       types.String                             `tfsdk:"ai_incident_summary"`
	AlertIds                []types.String                           `tfsdk:"alert_ids"`
	ChannelID               types.String                             `tfsdk:"channel_id"`
	ChannelName             types.String                             `tfsdk:"channel_name"`
	ChannelReference        types.String                             `tfsdk:"channel_reference"`
	ChannelStatus           types.String                             `tfsdk:"channel_status"`
	ConferenceBridges       []tfTypes.IncidentsConferenceBridge      `tfsdk:"conference_bridges"`
	ContextObject           *tfTypes.NullableIncidentsContextObject  `tfsdk:"context_object"`
	Conversations           []tfTypes.ConversationsAPIReference      `tfsdk:"conversations"`
	CreatedAt               types.String                             `tfsdk:"created_at"`
	CreatedBy               *tfTypes.NullableAuthor                  `tfsdk:"created_by"`
	CurrentMilestone        types.String                             `tfsdk:"current_milestone"`
	CustomFields            []tfTypes.CustomFieldsFieldValue         `tfsdk:"custom_fields"`
	CustomFieldsInput       []tfTypes.CustomFieldsInput              `tfsdk:"custom_fields_input"`
	CustomerImpactSummary   types.String                             `tfsdk:"customer_impact_summary"`
	CustomersImpacted       types.Int32                              `tfsdk:"customers_impacted"`
	Description             types.String                             `tfsdk:"description"`
	DiscardedAt             types.String                             `tfsdk:"discarded_at"`
	Environments            []tfTypes.Succinct                       `tfsdk:"environments"`
	ExternalLinks           types.String                             `tfsdk:"external_links"`
	FieldRequirements       []tfTypes.IncidentFieldRequirement       `tfsdk:"field_requirements"`
	Functionalities         []tfTypes.Succinct                       `tfsdk:"functionalities"`
	ID                      types.String                             `tfsdk:"id"`
	Impacts                 []tfTypes.IncidentsImpact                `tfsdk:"impacts"`
	ImpactsInput            []tfTypes.CreateIncidentImpactsInput     `tfsdk:"impacts_input"`
	IncidentChannels        []tfTypes.IncidentsChannel               `tfsdk:"incident_channels"`
	IncidentTickets         []tfTypes.TicketingTicket                `tfsdk:"incident_tickets"`
	IncidentType            *tfTypes.NullableSuccinct                `tfsdk:"incident_type"`
	IncidentTypeID          types.String                             `tfsdk:"incident_type_id"`
	IncidentURL             types.String                             `tfsdk:"incident_url"`
	Labels                  *tfTypes.CreateIncidentLabels            `tfsdk:"labels"`
	LastNote                *tfTypes.NullableEventNote               `tfsdk:"last_note"`
	LastUpdate              types.String                             `tfsdk:"last_update"`
	LifecycleMeasurements   []tfTypes.IncidentsLifecycleMeasurement  `tfsdk:"lifecycle_measurements"`
	LifecyclePhases         []tfTypes.IncidentsLifecyclePhase        `tfsdk:"lifecycle_phases"`
	Milestones              []tfTypes.IncidentsMilestone             `tfsdk:"milestones"`
	MilestonesInput         []tfTypes.MilestonesInput                `tfsdk:"milestones_input"`
	MonetaryImpact          types.Int32                              `tfsdk:"monetary_impact"`
	MonetaryImpactCents     types.Int32                              `tfsdk:"monetary_impact_cents"`
	Name                    types.String                             `tfsdk:"name"`
	Number                  types.Int32                              `tfsdk:"number"`
	Organization            *tfTypes.NullableOrganization            `tfsdk:"organization"`
	OrganizationID          types.String                             `tfsdk:"organization_id"`
	Priority                types.String                             `tfsdk:"priority"`
	PrivateID               types.String                             `tfsdk:"private_id"`
	PrivateStatusPageURL    types.String                             `tfsdk:"private_status_page_url"`
	ReportID                types.String                             `tfsdk:"report_id"`
	Restricted              types.Bool                               `tfsdk:"restricted"`
	RetroExports            []tfTypes.IncidentRetroExport            `tfsdk:"retro_exports"`
	RoleAssignments         []tfTypes.IncidentsRoleAssignment        `tfsdk:"role_assignments"`
	RunbookIds              []types.String                           `tfsdk:"runbook_ids"`
	Services                []tfTypes.Succinct                       `tfsdk:"services"`
	Severity                types.String                             `tfsdk:"severity"`
	SeverityColor           types.String                             `tfsdk:"severity_color"`
	SeverityCondition       types.String                             `tfsdk:"severity_condition"`
	SeverityConditionID     types.String                             `tfsdk:"severity_condition_id"`
	SeverityConditionObject *tfTypes.NullableSeverityMatrixCondition `tfsdk:"severity_condition_object"`
	SeverityImpact          types.String                             `tfsdk:"severity_impact"`
	SeverityImpactID        types.String                             `tfsdk:"severity_impact_id"`
	SeverityImpactObject    *tfTypes.NullableSeverityMatrixImpact    `tfsdk:"severity_impact_object"`
	SkipIncidentTypeValues  types.Bool                               `tfsdk:"skip_incident_type_values"`
	StartedAt               types.String                             `tfsdk:"started_at"`
	StatusPages             []tfTypes.IncidentsStatusPage            `tfsdk:"status_pages"`
	Summary                 types.String                             `tfsdk:"summary"`
	TagList                 []types.String                           `tfsdk:"tag_list"`
	TeamAssignments         []tfTypes.IncidentsTeamAssignmentLite    `tfsdk:"team_assignments"`
	TeamIds                 []types.String                           `tfsdk:"team_ids"`
	Ticket                  *tfTypes.NullableTicketingTicket         `tfsdk:"ticket"`
}

func (r *IncidentResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_incident"
}

func (r *IncidentResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Incident Resource",
		Attributes: map[string]schema.Attribute{
			"active": schema.BoolAttribute{
				Computed: true,
			},
			"ai_incident_summary": schema.StringAttribute{
				Computed: true,
			},
			"alert_ids": schema.ListAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplaceIfConfigured(),
				},
				ElementType: types.StringType,
				Description: `List of alert IDs that this incident should be associated to. Requires replacement if changed.`,
			},
			"channel_id": schema.StringAttribute{
				Computed: true,
			},
			"channel_name": schema.StringAttribute{
				Computed: true,
			},
			"channel_reference": schema.StringAttribute{
				Computed: true,
			},
			"channel_status": schema.StringAttribute{
				Computed:    true,
				Description: `inoperative: 0, operational: 1, archived: 2`,
			},
			"conference_bridges": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"attachments": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{},
							},
							Description: `A list of objects attached to this item. Can be one of: Link, CustomerSupportIssue, or GenericAttachment`,
						},
						"has_translated_transcripts": schema.BoolAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"language_codes": schema.ListAttribute{
							Computed:    true,
							ElementType: types.StringType,
							Description: `A list of language codes that have translated transcripts for this conference bridge`,
						},
						"previous_host_assignment": schema.StringAttribute{
							Computed: true,
						},
						"transcription_status": schema.StringAttribute{
							Computed: true,
						},
						"transcription_sub_code": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"context_object": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"context_description": schema.StringAttribute{
						Computed: true,
					},
					"context_tag": schema.StringAttribute{
						Computed: true,
					},
					"object_id": schema.StringAttribute{
						Computed: true,
					},
					"object_type": schema.StringAttribute{
						Computed: true,
					},
				},
			},
			"conversations": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"channel": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"comments_url": schema.StringAttribute{
							Computed: true,
						},
						"field": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"resource_class": schema.StringAttribute{
							Computed: true,
						},
						"resource_id": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"created_at": schema.StringAttribute{
				Computed:    true,
				Description: `The time the incident was opened`,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"created_by": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"email": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"source": schema.StringAttribute{
						Computed: true,
					},
				},
			},
			"current_milestone": schema.StringAttribute{
				Computed:    true,
				Description: `The type/slug of the current milestone. Will be one of the currently configured milestones for the given incident.`,
			},
			"custom_fields": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							Computed: true,
						},
						"display_name": schema.StringAttribute{
							Computed: true,
						},
						"field_id": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"slug": schema.StringAttribute{
							Computed: true,
						},
						"value": schema.StringAttribute{
							Computed: true,
						},
						"value_array": schema.ListAttribute{
							Computed:    true,
							ElementType: types.StringType,
						},
						"value_string": schema.StringAttribute{
							Computed: true,
						},
						"value_type": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"custom_fields_input": schema.ListNestedAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplaceIfConfigured(),
				},
				NestedObject: schema.NestedAttributeObject{
					PlanModifiers: []planmodifier.Object{
						objectplanmodifier.RequiresReplaceIfConfigured(),
					},
					Attributes: map[string]schema.Attribute{
						"field_id": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Description: `The ID of the custom field you wish to set. Requires replacement if changed.`,
						},
						"value_array": schema.ListAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.List{
								listplanmodifier.RequiresReplaceIfConfigured(),
							},
							ElementType: types.StringType,
							Description: `The value you wish to set on the custom field if the type of the field accepts array values. Requires replacement if changed.`,
						},
						"value_string": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Description: `The value you wish to set on the custom field if the type of the field accepts string values. Requires replacement if changed.`,
						},
					},
				},
				Description: `An array of custom fields to set on the incident. Requires replacement if changed.`,
			},
			"customer_impact_summary": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Requires replacement if changed.`,
			},
			"customers_impacted": schema.Int32Attribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Requires replacement if changed.`,
			},
			"discarded_at": schema.StringAttribute{
				Computed:    true,
				Description: `The time the incident was archived`,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"environments": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"external_links": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Description: `Requires replacement if changed.`,
			},
			"field_requirements": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"field_id": schema.StringAttribute{
							Computed:    true,
							Description: `A unique identifier for the field.`,
						},
						"required_at_milestone_id": schema.StringAttribute{
							Computed:    true,
							Description: `The milestone at which this field is required. If null, this field is always required.`,
						},
					},
				},
			},
			"functionalities": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `UUID of the Incident`,
			},
			"impacts": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"condition": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"position": schema.Int32Attribute{
									Computed:    true,
									Description: `Position is used to determine ordering of conditions in API responses and dropdowns. The condition with the lowest position (typically 0) will be considered the Default Condition`,
								},
							},
							Description: `SeverityMatrix_Condition model`,
						},
						"conversations": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"channel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"comments_url": schema.StringAttribute{
										Computed: true,
									},
									"field": schema.StringAttribute{
										Computed: true,
									},
									"id": schema.StringAttribute{
										Computed: true,
									},
									"resource_class": schema.StringAttribute{
										Computed: true,
									},
									"resource_id": schema.StringAttribute{
										Computed: true,
									},
								},
							},
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"impact": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"type": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"impacts_input": schema.ListNestedAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplaceIfConfigured(),
				},
				NestedObject: schema.NestedAttributeObject{
					PlanModifiers: []planmodifier.Object{
						objectplanmodifier.RequiresReplaceIfConfigured(),
					},
					Attributes: map[string]schema.Attribute{
						"condition_id": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Description: `The ID of the impact condition. Find these at /v1/severity_matrix/conditions. Requires replacement if changed.`,
						},
						"id": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Description: `The ID of the impacted infrastructure. Requires replacement if changed.`,
						},
						"type": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Description: `The type of impacted infrastructure. One of: environment, functionality, or service. Requires replacement if changed.`,
						},
					},
				},
				Description: `An array of impacted infrastructure. Requires replacement if changed.`,
			},
			"incident_channels": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"icon_url": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"source": schema.StringAttribute{
							Computed: true,
						},
						"source_id": schema.StringAttribute{
							Computed: true,
						},
						"source_name": schema.StringAttribute{
							Computed: true,
						},
						"status": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"incident_tickets": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"assignees": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"email": schema.StringAttribute{
										Computed: true,
									},
									"id": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"source": schema.StringAttribute{
										Computed: true,
									},
								},
							},
						},
						"attachments": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{},
							},
							Description: `A list of objects attached to this item. Can be one of: Link, CustomerSupportIssue, or GenericAttachment`,
						},
						"created_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"created_by": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"email": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"source": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"due_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"incident_current_milestone": schema.StringAttribute{
							Computed:    true,
							Description: `Milestone of incident that this ticket is related to`,
						},
						"incident_id": schema.StringAttribute{
							Computed:    true,
							Description: `ID of incident that this ticket is related to`,
						},
						"incident_name": schema.StringAttribute{
							Computed:    true,
							Description: `Name of incident that this ticket is related to`,
						},
						"link": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"deletable": schema.BoolAttribute{
									Computed:    true,
									Description: `Link can be deleted`,
								},
								"display_text": schema.StringAttribute{
									Computed: true,
								},
								"editable": schema.BoolAttribute{
									Computed:    true,
									Description: `Link can be edited`,
								},
								"href_url": schema.StringAttribute{
									Computed: true,
								},
								"icon_url": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"type": schema.StringAttribute{
									Computed: true,
								},
							},
							Description: `Attachments_Link model`,
						},
						"priority": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"created_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"position": schema.Int32Attribute{
									Computed: true,
								},
								"updated_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
							},
							Description: `Ticketing_Priority model`,
						},
						"state": schema.StringAttribute{
							Computed: true,
						},
						"summary": schema.StringAttribute{
							Computed: true,
						},
						"sync_error_message": schema.StringAttribute{
							Computed:    true,
							Description: `Error message from syncing this ticket to integrations`,
						},
						"tag_list": schema.ListAttribute{
							Computed:    true,
							ElementType: types.StringType,
						},
						"task_id": schema.StringAttribute{
							Computed:    true,
							Description: `ID of task that this ticket is related to`,
						},
						"type": schema.StringAttribute{
							Computed: true,
						},
						"updated_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
					},
				},
			},
			"incident_type": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
				},
			},
			"incident_type_id": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Description: `The ID of the incident type. This will copy values from the incident type (if any) unless they are being overridden via parameters in this request. Requires replacement if changed.`,
			},
			"incident_url": schema.StringAttribute{
				Computed: true,
			},
			"labels": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Description: `Key:value pairs to track custom data for the incident. Requires replacement if changed.`,
			},
			"last_note": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"body": schema.StringAttribute{
						Computed: true,
					},
					"conversations": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"channel": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
										},
									},
								},
								"comments_url": schema.StringAttribute{
									Computed: true,
								},
								"field": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"resource_class": schema.StringAttribute{
									Computed: true,
								},
								"resource_id": schema.StringAttribute{
									Computed: true,
								},
							},
						},
					},
					"created_at": schema.StringAttribute{
						Computed: true,
						Validators: []validator.String{
							validators.IsRFC3339(),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"status_pages": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"display_name": schema.StringAttribute{
									Computed: true,
								},
								"external_id": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"integration": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"created_at": schema.StringAttribute{
											Computed: true,
											Validators: []validator.String{
												validators.IsRFC3339(),
											},
										},
										"display_name": schema.StringAttribute{
											Computed: true,
										},
										"id": schema.StringAttribute{
											Computed: true,
										},
										"integration_name": schema.StringAttribute{
											Computed: true,
										},
										"integration_slug": schema.StringAttribute{
											Computed: true,
										},
									},
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
						},
					},
				},
				Description: `Event_Note model`,
			},
			"last_update": schema.StringAttribute{
				Computed: true,
			},
			"lifecycle_measurements": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"calculated_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"ends_at_milestone": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"slug": schema.StringAttribute{
							Computed: true,
						},
						"starts_at_milestone": schema.StringAttribute{
							Computed: true,
						},
						"value": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"lifecycle_phases": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"milestones": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"description": schema.StringAttribute{
										Computed: true,
									},
									"duration": schema.StringAttribute{
										Computed: true,
									},
									"id": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"occurred_at": schema.StringAttribute{
										Computed: true,
										Validators: []validator.String{
											validators.IsRFC3339(),
										},
									},
									"position": schema.Int32Attribute{
										Computed: true,
									},
									"slug": schema.StringAttribute{
										Computed: true,
									},
									"updated_at": schema.StringAttribute{
										Computed: true,
										Validators: []validator.String{
											validators.IsRFC3339(),
										},
									},
									"updated_by": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"email": schema.StringAttribute{
												Computed: true,
											},
											"id": schema.StringAttribute{
												Computed: true,
											},
											"name": schema.StringAttribute{
												Computed: true,
											},
											"source": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
							},
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"position": schema.Int32Attribute{
							Computed: true,
						},
						"type": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"milestones": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"duration": schema.StringAttribute{
							Computed:    true,
							Description: `How long the incident spent in this milestones, in ISO 8601 Duration Format. This will be null if the milestone is the incident's current milestone.`,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"occurred_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"type": schema.StringAttribute{
							Computed:    true,
							Description: `The milestone's type. This will be one of the currently configured milestones for the given incident.`,
						},
						"updated_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
					},
				},
				Description: `DEPRECATED: Please use lifecycle phases instead`,
			},
			"milestones_input": schema.ListNestedAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplaceIfConfigured(),
				},
				NestedObject: schema.NestedAttributeObject{
					PlanModifiers: []planmodifier.Object{
						objectplanmodifier.RequiresReplaceIfConfigured(),
					},
					Attributes: map[string]schema.Attribute{
						"occurred_at": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Description: `An ISO8601 formatted string for when this milestone occurred. If you are removing a milestone, this field still needs to be set to some value. Requires replacement if changed.`,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"type": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Description: `The type/slug of the milestone. Must be one of the currently configured milestones. Requires replacement if changed.`,
						},
					},
				},
				Description: `An array of milestones to set on an incident. This can be used to create an already-resolved incident. Requires replacement if changed.`,
			},
			"monetary_impact": schema.Int32Attribute{
				Computed: true,
			},
			"monetary_impact_cents": schema.Int32Attribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Requires replacement if changed.`,
			},
			"number": schema.Int32Attribute{
				Computed:    true,
				Description: `Incident number`,
			},
			"organization": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
				},
			},
			"organization_id": schema.StringAttribute{
				Computed: true,
			},
			"priority": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Requires replacement if changed.`,
			},
			"private_id": schema.StringAttribute{
				Computed: true,
			},
			"private_status_page_url": schema.StringAttribute{
				Computed: true,
			},
			"report_id": schema.StringAttribute{
				Computed: true,
			},
			"restricted": schema.BoolAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplaceIfConfigured(),
				},
				Description: `Requires replacement if changed.`,
			},
			"retro_exports": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{},
				},
				Description: `A list of objects attached to this item. Can be one of: Link, CustomerSupportIssue, or GenericAttachment`,
			},
			"role_assignments": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"incident_role": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"created_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"description": schema.StringAttribute{
									Computed: true,
								},
								"discarded_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"summary": schema.StringAttribute{
									Computed: true,
								},
								"updated_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
							},
							Description: `IncidentRole model`,
						},
						"status": schema.StringAttribute{
							Computed: true,
						},
						"updated_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"user": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"created_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"email": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"signals_enabled_notification_types": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"signals_notification_policy_compliance": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"is_compliant": schema.BoolAttribute{
												Computed: true,
											},
											"notification_policy_item_id": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
								"slack_linked": schema.BoolAttribute{
									Computed: true,
								},
								"slack_user_id": schema.StringAttribute{
									Computed: true,
								},
								"updated_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
							},
							Description: `User model`,
						},
					},
				},
			},
			"runbook_ids": schema.ListAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplaceIfConfigured(),
				},
				ElementType: types.StringType,
				Description: `List of ids of Runbooks to attach to this incident. Foregoes any conditions these Runbooks may have guarding automatic attachment. Requires replacement if changed.`,
			},
			"services": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"severity": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Requires replacement if changed.`,
			},
			"severity_color": schema.StringAttribute{
				Computed: true,
			},
			"severity_condition": schema.StringAttribute{
				Computed: true,
			},
			"severity_condition_id": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Description: `Requires replacement if changed.`,
			},
			"severity_condition_object": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"position": schema.Int32Attribute{
						Computed:    true,
						Description: `Position is used to determine ordering of conditions in API responses and dropdowns. The condition with the lowest position (typically 0) will be considered the Default Condition`,
					},
				},
				Description: `SeverityMatrix_Condition model`,
			},
			"severity_impact": schema.StringAttribute{
				Computed: true,
			},
			"severity_impact_id": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Description: `Requires replacement if changed.`,
			},
			"severity_impact_object": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"affects_id": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"position": schema.Int32Attribute{
						Computed: true,
					},
					"type": schema.StringAttribute{
						Computed: true,
					},
				},
				Description: `SeverityMatrix_Impact model`,
			},
			"skip_incident_type_values": schema.BoolAttribute{
				Computed: true,
				Optional: true,
				Default:  booldefault.StaticBool(false),
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplaceIfConfigured(),
				},
				Description: `If true, the incident type values will not be copied to the incident. This is useful when creating an incident from an incident type, but you want to set the values manually. Default: false; Requires replacement if changed.`,
			},
			"started_at": schema.StringAttribute{
				Computed:    true,
				Description: `The time the incident started`,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"status_pages": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"display_name": schema.StringAttribute{
							Computed: true,
						},
						"external_id": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"integration": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"created_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"display_name": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"integration_name": schema.StringAttribute{
									Computed: true,
								},
								"integration_slug": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"summary": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Requires replacement if changed.`,
			},
			"tag_list": schema.ListAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
				},
				ElementType: types.StringType,
				Description: `List of tags for the incident. Requires replacement if changed.`,
			},
			"team_assignments": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"status": schema.StringAttribute{
							Computed: true,
						},
						"team": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"created_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"created_by": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"email": schema.StringAttribute{
											Computed: true,
										},
										"id": schema.StringAttribute{
											Computed: true,
										},
										"name": schema.StringAttribute{
											Computed: true,
										},
										"source": schema.StringAttribute{
											Computed: true,
										},
									},
								},
								"description": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"in_support_hours": schema.BoolAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"signals_ical_url": schema.StringAttribute{
									Computed: true,
								},
								"slug": schema.StringAttribute{
									Computed: true,
								},
								"updated_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
							},
						},
						"updated_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
					},
				},
			},
			"team_ids": schema.ListAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplaceIfConfigured(),
				},
				ElementType: types.StringType,
				Description: `IDs of teams you wish to assign to this incident. Requires replacement if changed.`,
			},
			"ticket": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"assignees": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"email": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"source": schema.StringAttribute{
									Computed: true,
								},
							},
						},
					},
					"attachments": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{},
						},
						Description: `A list of objects attached to this item. Can be one of: Link, CustomerSupportIssue, or GenericAttachment`,
					},
					"created_at": schema.StringAttribute{
						Computed: true,
						Validators: []validator.String{
							validators.IsRFC3339(),
						},
					},
					"created_by": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"email": schema.StringAttribute{
								Computed: true,
							},
							"id": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"source": schema.StringAttribute{
								Computed: true,
							},
						},
					},
					"description": schema.StringAttribute{
						Computed: true,
					},
					"due_at": schema.StringAttribute{
						Computed: true,
						Validators: []validator.String{
							validators.IsRFC3339(),
						},
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"incident_current_milestone": schema.StringAttribute{
						Computed:    true,
						Description: `Milestone of incident that this ticket is related to`,
					},
					"incident_id": schema.StringAttribute{
						Computed:    true,
						Description: `ID of incident that this ticket is related to`,
					},
					"incident_name": schema.StringAttribute{
						Computed:    true,
						Description: `Name of incident that this ticket is related to`,
					},
					"link": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"deletable": schema.BoolAttribute{
								Computed:    true,
								Description: `Link can be deleted`,
							},
							"display_text": schema.StringAttribute{
								Computed: true,
							},
							"editable": schema.BoolAttribute{
								Computed:    true,
								Description: `Link can be edited`,
							},
							"href_url": schema.StringAttribute{
								Computed: true,
							},
							"icon_url": schema.StringAttribute{
								Computed: true,
							},
							"id": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Attachments_Link model`,
					},
					"priority": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"created_at": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"id": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"position": schema.Int32Attribute{
								Computed: true,
							},
							"updated_at": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `Ticketing_Priority model`,
					},
					"state": schema.StringAttribute{
						Computed: true,
					},
					"summary": schema.StringAttribute{
						Computed: true,
					},
					"sync_error_message": schema.StringAttribute{
						Computed:    true,
						Description: `Error message from syncing this ticket to integrations`,
					},
					"tag_list": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"task_id": schema.StringAttribute{
						Computed:    true,
						Description: `ID of task that this ticket is related to`,
					},
					"type": schema.StringAttribute{
						Computed: true,
					},
					"updated_at": schema.StringAttribute{
						Computed: true,
						Validators: []validator.String{
							validators.IsRFC3339(),
						},
					},
				},
				Description: `Ticketing_Ticket model`,
			},
		},
	}
}

func (r *IncidentResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.Firehydrant)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.Firehydrant, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *IncidentResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *IncidentResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToSharedCreateIncident(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Incidents.CreateIncident(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 201 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Incident != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedIncident(ctx, res.Incident)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetIncidentRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Incidents.GetIncident(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Incident != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedIncident(ctx, res1.Incident)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *IncidentResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *IncidentResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsGetIncidentRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Incidents.GetIncident(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Incident != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedIncident(ctx, res.Incident)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *IncidentResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *IncidentResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsCloseIncidentRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Incidents.CloseIncident(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Incident != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedIncident(ctx, res.Incident)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *IncidentResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *IncidentResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsDeleteIncidentRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Incidents.DeleteIncident(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *IncidentResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
}
